<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Single-file WebRTC Voice Room (Discord-like)</title>
<!-- Minimal Discord-like styling -->
<style>
  :root{
    --sidebar:#2f3136; --bg:#36393f; --panel:#2b2d31; --accent:#7289da; --muted:#b9bbbe; --text:#e3e5e8;
  }
  html,body{height:100%;margin:0;font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue"; background:linear-gradient(180deg,var(--bg),#2f3136);color:var(--text);}
  .app{display:grid;grid-template-columns:260px 1fr;height:100vh;gap:16px;padding:16px;}
  .sidebar{background:var(--sidebar);border-radius:12px;padding:12px;display:flex;flex-direction:column;gap:12px;}
  .server-title{font-weight:700;color:var(--text);padding:6px 10px;border-bottom:1px solid rgba(255,255,255,0.03);}
  .channels{flex:1;overflow:auto;}
  .channel{padding:10px;border-radius:8px;margin:6px 0;display:flex;align-items:center;gap:8px;cursor:pointer;color:var(--muted);}
  .channel.active{background:rgba(114,137,218,0.12);color:var(--text);font-weight:600;}
  .main{display:flex;flex-direction:column;gap:12px;padding:12px;border-radius:12px;background:linear-gradient(180deg, rgba(0,0,0,0.12), rgba(0,0,0,0.06));}
  .room-header{display:flex;align-items:center;justify-content:space-between;}
  .room-title{font-size:18px;font-weight:700;}
  .controls{display:flex;gap:8px;align-items:center;}
  button{background:var(--panel);border:1px solid rgba(255,255,255,0.03);color:var(--text);padding:8px 12px;border-radius:8px;cursor:pointer;}
  .btn-muted{background:#2a2b2f;color:var(--muted);}
  .participants{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px;margin-top:12px;}
  .participant{background:var(--panel);padding:10px;border-radius:10px;display:flex;gap:10px;align-items:center;}
  .avatar{width:44px;height:44px;border-radius:8px;background:linear-gradient(135deg,var(--accent),#5b6bd1);display:flex;align-items:center;justify-content:center;font-weight:700;color:white;}
  .pmeta{flex:1;min-width:0;}
  .pname{font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
  .pstatus{font-size:12px;color:var(--muted);margin-top:4px;}
  .small{font-size:13px;color:var(--muted);}
  .controls .status-dot{width:10px;height:10px;border-radius:50%;background:#4caf50;margin-left:6px;display:inline-block;}
  .footer{display:flex;align-items:center;justify-content:space-between;padding-top:10px;border-top:1px solid rgba(255,255,255,0.03);margin-top:8px;}
  .mutebtn{background:#202225;border:1px solid rgba(0,0,0,0.3);color:var(--text);}
  .leave{background:#2b2b2b;color:#ff8b8b;}
</style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="server-title">My Voice Server</div>
    <div class="channels">
      <div class="channel active">ðŸ”Š general-voice</div>
      <div class="channel">ðŸŽ® gaming</div>
      <div class="channel">ðŸ’¬ lobby</div>
    </div>
    <div style="font-size:13px;color:var(--muted);padding-top:8px;">Status: <span id="connStatus">disconnected</span></div>
  </aside>

  <main class="main">
    <div class="room-header">
      <div>
        <div class="room-title"># general-voice</div>
        <div class="small">A simple WebRTC voice room. Up to 10 participants.</div>
      </div>
      <div class="controls">
        <div id="micIndicator" class="small">Mic: <strong id="micState">off</strong></div>
        <button id="joinBtn">Join</button>
        <button id="leaveBtn" class="leave" style="display:none">Leave</button>
        <button id="toggleMute" class="mutebtn" style="display:none">Mute</button>
      </div>
    </div>

    <div>
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <div style="font-weight:700">Participants (<span id="memberCount">0</span>)</div>
        <div class="small">Tap a participant to mute their audio locally</div>
      </div>

      <div id="participants" class="participants" aria-live="polite"></div>
    </div>

    <div class="footer">
      <div class="small">Your name: <input id="displayName" placeholder="Pick a name" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.04);background:#222;color:var(--text)"></div>
      <div class="small">Room ID: <strong id="roomId">general-voice</strong></div>
    </div>
  </main>
</div>

<!-- ScaleDrone JS -->
<script src="https://cdn.scaledrone.com/scaledrone.min.js"></script>
<script>
/*
  Single-file WebRTC voice room using ScaleDrone signaling.
  Replace CHANNEL_ID with your ScaleDrone channel ID (string).
  ScaleDrone docs: https://www.scaledrone.com/ (create channel and copy its ID)
*/

// --------- CONFIG ----------
const CHANNEL_ID = "YstSSj9UMw4xqYdB"; // <<--- REPLACE with your channel ID
const ROOM_NAME = "observable-general-voice"; // room name for signaling (ScaleDrone 'observable-' prefix recommended)

// limits
const MAX_PARTICIPANTS = 10;

// UI elements
const joinBtn = document.getElementById('joinBtn');
const leaveBtn = document.getElementById('leaveBtn');
const toggleMuteBtn = document.getElementById('toggleMute');
const micStateEl = document.getElementById('micState');
const micIndicator = document.getElementById('micIndicator');
const participantsEl = document.getElementById('participants');
const memberCountEl = document.getElementById('memberCount');
const connStatus = document.getElementById('connStatus');
const displayNameInput = document.getElementById('displayName');

let localStream = null;
let drone = null;
let room = null;
let clientId = null;
let peers = {}; // map clientId -> { pc, audioEl, name }
let isJoined = false;
let isMuted = false;

// utility to create random short ID
function shortId() { return Math.random().toString(36).substring(2,9); }

// Update participants UI
function renderParticipants(){
  participantsEl.innerHTML = '';
  const ids = Object.keys(peers);
  memberCountEl.textContent = ids.length + (isJoined ? 1 : 0);
  // local tile first
  if(isJoined){
    const localTile = document.createElement('div');
    localTile.className = 'participant';
    localTile.innerHTML = `
      <div class="avatar">You</div>
      <div class="pmeta">
        <div class="pname">${displayNameInput.value || 'You (local)'}</div>
        <div class="pstatus">${isMuted ? 'muted' : 'speaking (mic on)'}</div>
      </div>
      <div>
        <button id="localToggle" class="mutebtn">${isMuted ? 'Unmute' : 'Mute'}</button>
      </div>
    `;
    participantsEl.appendChild(localTile);
    localTile.querySelector('#localToggle').onclick = toggleLocalMute;
  }

  ids.slice(0, MAX_PARTICIPANTS).forEach(id=>{
    const p = peers[id];
    const tile = document.createElement('div');
    tile.className = 'participant';
    tile.dataset.client = id;
    tile.innerHTML = `
      <div class="avatar">${(p.name||'U').slice(0,2).toUpperCase()}</div>
      <div class="pmeta">
        <div class="pname">${p.name || ('User-'+id.slice(0,4))}</div>
        <div class="pstatus" id="status-${id}">connected</div>
      </div>
      <div>
        <button class="mutebtn" data-id="${id}">Mute</button>
      </div>
    `;
    participantsEl.appendChild(tile);
    // playback mute per participant
    tile.querySelector('button').addEventListener('click', ()=>{
      const audio = p.audioEl;
      if(!audio) return;
      audio.muted = !audio.muted;
      tile.querySelector('button').textContent = audio.muted ? 'Unmute' : 'Mute';
    });
  });
}

// Toggle local microphone on/off
function toggleLocalMute(){
  if(!localStream) return;
  isMuted = !isMuted;
  localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
  micStateEl.textContent = isMuted ? 'off' : 'on';
  toggleMuteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
  renderParticipants();
}

// Create audio element for a remote stream and attach
function createAudioElForStream(stream, id){
  const audio = document.createElement('audio');
  audio.autoplay = true;
  audio.playsInline = true;
  audio.srcObject = stream;
  audio.id = 'audio-'+id;
  audio.volume = 1.0;
  // keep hidden but available
  audio.style.display = 'none';
  document.body.appendChild(audio);
  return audio;
}

// Clean up peer
function closePeer(id){
  if(!peers[id]) return;
  try{ peers[id].pc.close(); } catch(e){}
  if(peers[id].audioEl){ peers[id].audioEl.remove(); }
  delete peers[id];
  renderParticipants();
}

// Set connection status display
function setConn(text){
  connStatus.textContent = text;
}

// Start â€” connect to ScaleDrone and prepare local media
async function joinRoom(){
  if(!CHANNEL_ID || CHANNEL_ID === "YOUR_CHANNEL_ID"){
    alert('Please replace CHANNEL_ID with your ScaleDrone channel ID in the code.');
    return;
  }
  if(isJoined) return;
  // create drone client
  drone = new ScaleDrone(CHANNEL_ID, { data: { name: displayNameInput.value || ('Guest-'+shortId()) } });
  setConn('connecting');
  drone.on('open', error => {
    if (error) { console.error(error); setConn('error'); return; }
    setConn('connected to signaling');
    clientId = drone.clientId;
    // subscribe to room for signaling
    room = drone.subscribe(ROOM_NAME);
    room.on('open', err => {
      if(err) console.error('room open error', err);
    });

    // members list: keep peers in sync
    room.on('members', m => {
      // members is an array of {id, clientData}
      // Remove peers that are no longer present
      const remoteIds = m.map(x => x.id).filter(id => id !== clientId);
      Object.keys(peers).forEach(id => {
        if(!remoteIds.includes(id)) closePeer(id);
      });
      // show current members
      renderParticipants();
    });

    // handle signaling messages
    room.on('data', (message, member) => {
      if(!member) return;
      const from = member.id;
      if(from === clientId) return; // ignore our own messages
      if(typeof message !== 'object' || !message.type) return;

      if(message.type === 'offer'){
        // incoming offer -> create peer, set remote desc, create and send answer
        const pc = preparePeerConnection(from, false);
        pc.setRemoteDescription(new RTCSessionDescription(message.sdp)).then(()=>{
          return pc.createAnswer();
        }).then(answer=>{
          return pc.setLocalDescription(answer);
        }).then(()=>{
          drone.publish({ room: ROOM_NAME, message: { type: 'answer', sdp: pc.localDescription, name: message.name }});
        }).catch(console.error);

      } else if(message.type === 'answer'){
        // remote answer to our offer
        const pcObj = peers[from];
        if(pcObj && pcObj.pc){
          pcObj.pc.setRemoteDescription(new RTCSessionDescription(message.sdp)).catch(console.error);
        }

      } else if(message.type === 'candidate'){
        const pcObj = peers[from];
        if(pcObj && pcObj.pc){
          pcObj.pc.addIceCandidate(new RTCIceCandidate(message.candidate)).catch(console.error);
        }
      }
    });

    // now get user media
    initLocalMediaAndOffer();
  });

  drone.on('close', ()=> setConn('signaling closed'));
  drone.on('error', err => { console.error(err); setConn('signaling error'); });
}

// get microphone & make offers to other members
async function initLocalMediaAndOffer(){
  try{
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    isMuted = false;
    micStateEl.textContent = 'on';
    toggleMuteBtn.style.display = '';
    leaveBtn.style.display = '';
    joinBtn.style.display = 'none';
    isJoined = true;
    renderParticipants();

    // after we are in a room, get current members and offer to each
    const members = room.members || [];
    // Offer to each existing remote member
    members.forEach(member => {
      if(member.id === clientId) return;
      createOfferFor(member.id, member.clientData && member.clientData.name);
    });

    // Also listen for future joins (ScaleDrone triggers members list, but not 'member_join' event reliably)
    room.on('member_join', member => {
      // create offer to newly joined
      if(member.id === clientId) return;
      createOfferFor(member.id, member.clientData && member.clientData.name);
    });

  } catch(err){
    console.error('getUserMedia error', err);
    alert('Microphone access is required to join voice chat.');
    setConn('mic blocked');
  }
}

// Prepare RTCPeerConnection and event handlers
function preparePeerConnection(remoteId, isOfferer=true){
  if(peers[remoteId] && peers[remoteId].pc) return peers[remoteId].pc;
  const pc = new RTCPeerConnection({
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  });
  // create placeholder peer record
  peers[remoteId] = peers[remoteId] || { pc, audioEl: null, name: '' };
  peers[remoteId].pc = pc;

  // add local tracks to PC
  if(localStream){
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
  }

  // ICE candidate -> send to other via ScaleDrone
  pc.onicecandidate = event => {
    if(event.candidate){
      drone.publish({ room: ROOM_NAME, message: { type: 'candidate', candidate: event.candidate }});
    }
  };

  // remote track received
  pc.ontrack = ev => {
    // Some browsers deliver multiple tracks in one event; take the first stream
    const stream = ev.streams && ev.streams[0] ? ev.streams[0] : new MediaStream(ev.track ? [ev.track] : []);
    // create audio element for it
    const audioEl = createAudioElForStream(stream, remoteId);
    peers[remoteId].audioEl = audioEl;
    // update name if known
    peers[remoteId].name = peers[remoteId].name || ('User-' + remoteId.slice(0,4));
    renderParticipants();
  };

  pc.onconnectionstatechange = () => {
    if(pc.connectionState === 'failed' || pc.connectionState === 'disconnected' || pc.connectionState === 'closed'){
      closePeer(remoteId);
    }
  };

  return pc;
}

// create offer for a specific remote id; send offer via ScaleDrone
async function createOfferFor(remoteId, remoteName){
  // prepare peer
  const pc = preparePeerConnection(remoteId, true);
  // attach remote name
  peers[remoteId].name = remoteName || peers[remoteId].name || ('User-'+remoteId.slice(0,4));

  try{
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    // send offer via signaling channel
    drone.publish({ room: ROOM_NAME, message: { type: 'offer', sdp: pc.localDescription, name: displayNameInput.value || ('Guest-'+shortId()) }});
  } catch(e){ console.error('Offer error', e); }
}

// Leave room and cleanup
function leaveRoom(){
  // close peers
  Object.keys(peers).forEach(id => {
    try{ peers[id].pc.close(); } catch(e){}
    if(peers[id].audioEl) peers[id].audioEl.remove();
  });
  peers = {};
  // stop local media
  if(localStream){
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
  }

  // unsubscribe/close drone
  try{ if(room) room.unsubscribe(); } catch(e){}
  try{ if(drone) drone.close(); } catch(e){}
  drone = null;
  room = null;
  clientId = null;
  isJoined = false;
  isMuted = false;
  micStateEl.textContent = 'off';
  toggleMuteBtn.style.display = 'none';
  leaveBtn.style.display = 'none';
  joinBtn.style.display = '';
  setConn('disconnected');
  renderParticipants();
}

// Button wiring
joinBtn.onclick = () => {
  joinRoom();
  // show hint: require HTTPS/localhost
  if(location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1'){
    console.warn('WebRTC requires HTTPS to access microphone â€” run on localhost or via HTTPS.');
  }
};
leaveBtn.onclick = leaveRoom;
toggleMuteBtn.onclick = toggleLocalMute;

// initial UI render
renderParticipants();
setConn('idle');

</script>
</body>
</html>
