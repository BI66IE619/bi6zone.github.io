<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BI6CORD â€” Voice Only (Fixed Presence & VC)</title>

<!-- Scaledrone SDK -->
<script src="https://cdn.scaledrone.com/scaledrone.min.js"></script>

<style>
  :root{
    --bg:#36393F; --sidebar:#2c2d31; --serverbar:#1f1e23; --muted:#96989D;
    --accent:#5865F2; --card:#232428; --panel:#40444B; --text:#DCDDDE;
  }
  *{box-sizing:border-box;margin:0;padding:0;font-family:"Segoe UI",Tahoma,Geneva,Verdana,sans-serif}
  html,body{height:100%;background:var(--bg);color:var(--text)}
  .app{display:flex;height:100vh;width:100vw;overflow:hidden}

  /* left server column */
  .server-sidebar{width:72px;background:var(--serverbar);padding:12px 8px;display:flex;flex-direction:column;align-items:center;gap:8px}
  .server-icon{width:48px;height:48px;border-radius:24px;background:var(--accent);display:flex;align-items:center;justify-content:center;cursor:pointer}
  .nav-icon{width:48px;height:48px;border-radius:24px;background:var(--bg);display:flex;align-items:center;justify-content:center;cursor:pointer}
  .nav-icon img,.server-icon img{width:22px;height:22px;filter:invert(1)}

  /* channel column */
  .channel-sidebar{width:260px;background:var(--sidebar);display:flex;flex-direction:column}
  .server-header{height:48px;display:flex;align-items:center;padding:0 16px;border-bottom:1px solid #1e1f22;font-weight:600;cursor:pointer}
  .channels-container{padding:12px 8px;overflow:auto;flex:1}
  .channel-category{padding:8px 8px;font-size:12px;font-weight:700;color:var(--muted);text-transform:uppercase;letter-spacing:0.04em;display:flex;justify-content:space-between;align-items:center}
  .channel-item{padding:8px 10px;border-radius:6px;margin:6px 4px;cursor:pointer;color:var(--muted);display:flex;align-items:center;gap:8px}
  .channel-item:hover{background:#35373C;color:var(--text)}
  .channel-item.active{background:#404249;color:var(--text)}

  /* main area */
  .chat-area{flex:1;display:flex;flex-direction:column;background:var(--bg)}
  .chat-header{height:64px;display:flex;align-items:center;justify-content:space-between;padding:0 16px;border-bottom:1px solid #1e1f22}
  .channel-title{font-weight:700;font-size:18px;display:flex;gap:10px;align-items:center}
  .content{flex:1;padding:20px;overflow:auto}
  .status-card{background:var(--card);padding:18px;border-radius:10px;border:1px solid #1e1f22;max-width:900px}

  /* members */
  .members-sidebar{width:320px;background:var(--sidebar);border-left:1px solid #1e1f22;display:flex;flex-direction:column}
  .members-header{height:48px;display:flex;align-items:center;padding:0 16px;border-bottom:1px solid #1e1f22;font-weight:600;color:var(--text)}
  .members-content{padding:12px;overflow:auto;flex:1}
  .member-item{display:flex;align-items:center;gap:10px;padding:6px 8px;border-radius:6px}
  .member-avatar{width:36px;height:36px;border-radius:50%;background:var(--accent);display:flex;align-items:center;justify-content:center;font-weight:700;color:white}
  .member-name{font-size:14px;font-weight:600;color:var(--text)}
  .member-presence{font-size:12px;color:var(--muted)}

  /* voice participants panel */
  .voice-participants { margin-top:12px; padding-top:8px; border-top:1px dashed #2a2a2a; }
  .voice-participants-title { font-size:12px; color:var(--muted); margin-bottom:8px; text-transform:uppercase; letter-spacing:0.04em; }

  /* controls & buttons */
  .controls{display:flex;gap:8px;align-items:center}
  .cta-btn{background:var(--accent);color:white;padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
  .mutebtn{background:#2f3136;color:var(--text);padding:8px 12px;border-radius:8px;border:1px solid #1e1f22;cursor:pointer}

  audio{display:none}
  @media (max-width:1000px){.members-sidebar{display:none}}
</style>
</head>

<body>
<div class="app">

  <!-- SERVER SIDEBAR -->
  <div class="server-sidebar">
    <a class="server-icon" title="Home"><img src="https://img.icons8.com/ios-filled/50/ffffff/discord-logo.png" alt=""></a>
    <div style="height:8px"></div>
    <a class="nav-icon" title="Home"><img src="https://img.icons8.com/ios-filled/50/ffffff/home.png" alt=""></a>
    <a class="nav-icon" title="Games"><img src="https://img.icons8.com/ios-filled/50/ffffff/controller.png" alt=""></a>
  </div>

  <!-- CHANNEL / VOICE SIDEBAR -->
  <div class="channel-sidebar">
    <div class="server-header">Unblockedcord</div>

    <div class="channels-container">
      <div class="channel-category"><span>Voice Channels</span></div>

      <div class="channel-item voice-channel" vc="voice-lobby" onclick="toggleJoinVoice('voice-lobby')">
        <span>ðŸ”Š</span><span>voice-lobby</span>
      </div>

      <div class="channel-item voice-channel" vc="gaming-vc" onclick="toggleJoinVoice('gaming-vc')">
        <span>ðŸŽ®</span><span>gaming-vc</span>
      </div>

      <div class="channel-item voice-channel" vc="chill-vc" onclick="toggleJoinVoice('chill-vc')">
        <span>ðŸ˜Ž</span><span>chill-vc</span>
      </div>

      <div style="height:12px"></div>
      <div class="channel-category"><span>Presence</span></div>
      <div style="padding:8px;color:var(--muted);font-size:13px;"><span id="presentCount">0</span> users online</div>
    </div>

    <!-- user mini card -->
    <div style="padding:10px;border-top:1px solid #1e1f22;">
      <div style="display:flex;gap:8px;align-items:center;">
        <div id="myAvatar" class="member-avatar">U</div>
        <div style="flex:1;">
          <div id="myName" style="font-weight:700;color:var(--text);font-size:14px;">Connecting...</div>
          <div id="myStatus" style="font-size:12px;color:var(--muted)">Offline</div>
        </div>
        <button id="leaveBtn" class="cta-btn" onclick="leaveVoiceIfJoined()" style="padding:6px 8px;">Leave</button>
      </div>
    </div>
  </div>

  <!-- MAIN AREA -->
  <div class="chat-area">
    <div class="chat-header">
      <div class="channel-title" id="headerTitle">No voice channel selected</div>
      <div class="controls">
        <div id="vcStatus" style="color:var(--muted)">Not connected</div>
        <button id="muteBtn" class="mutebtn" onclick="toggleMute()" title="Mute / Unmute">Mute</button>
      </div>
    </div>

    <div class="content">
      <div class="status-card" id="statusCard">
        <h2 id="cardTitle">Welcome to Unblockedcord Voice</h2>
        <p id="cardBody" style="margin-top:8px;color:var(--muted);line-height:1.45;">
          Click a voice channel on the left to join. Your browser will ask for microphone permission.
        </p>
        <div style="margin-top:12px;">
          <button class="cta-btn" onclick="promptJoinLast()">Join last channel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- MEMBERS SIDEBAR -->
  <div class="members-sidebar">
    <div class="members-header">Members â€” <span id="membersCountHeader">0</span></div>
    <div class="members-content" id="membersList"></div>

    <!-- Voice participants panel under members -->
    <div style="padding:12px;border-top:1px solid #1e1f22;">
      <div class="voice-participants-title">Voice â€” <span id="vpTitle">â€”</span></div>
      <div id="voiceParticipants"></div>
    </div>
  </div>
</div>

<!-- Hidden audio container for remote streams -->
<div id="audioContainer" style="display:none;"></div>

<script>
/* ======== Voice-only app (up to ~10 peers per channel) with FIXED PRESENCE ========
   - Replace CLIENT_ID with your Scaledrone ID
   - Serve over HTTPS (or localhost)
   - Uses a single ScaleDrone instance for presence + signaling
   - Proper cleanup on join/leave; maintains presence map for accurate member counts
================================================================= */

const CLIENT_ID = "YOUR_SCALEDONE_CHANNEL_ID"; // <<-- REPLACE
const PRESENCE_ROOM = "observable-presence";
const VOICE_ROOM_PREFIX = "observable-voice-";
const VOICE_CHANNELS = ["voice-lobby","gaming-vc","chill-vc"];
const MAX_PEERS = 10;

let drone = null;
let currentUser = null;
let presenceRoom = null;
let voiceRoom = null;
let localStream = null;
let pcs = {}; // peerId -> RTCPeerConnection
let joinedChannel = null;
let muted = false;

// presence tracking using Map (id -> clientData)
let presenceMembers = new Map();

// track voice room members per roomName (Map roomName -> Map(peerId -> clientData))
let voiceRoomMembers = new Map();

// UI refs
const membersListEl = document.getElementById('membersList');
const membersCountHeader = document.getElementById('membersCountHeader');
const presentCountEl = document.getElementById('presentCount');
const headerTitle = document.getElementById('headerTitle');
const vcStatus = document.getElementById('vcStatus');
const myNameEl = document.getElementById('myName');
const myStatusEl = document.getElementById('myStatus');
const myAvatarEl = document.getElementById('myAvatar');
const audioContainer = document.getElementById('audioContainer');
const voiceParticipantsEl = document.getElementById('voiceParticipants');
const vpTitleEl = document.getElementById('vpTitle');
const muteBtn = document.getElementById('muteBtn');

function getRandomName(){
  const adjs=["quiet","blue","brave","wild","lucky","shadow","crimson","silent","icy","bold"];
  const nouns=["river","moon","breeze","pine","cloud","glade","star","ember","dawn","forest"];
  return adjs[Math.floor(Math.random()*adjs.length)]+'_'+nouns[Math.floor(Math.random()*nouns.length)];
}
function getRandomColor(){
  let c=Math.floor(Math.random()*0xFFFFFF).toString(16); while(c.length<6)c='0'+c; return '#'+c;
}
function shortIdFromName(name){ return (name||'U').slice(0,1).toUpperCase(); }

// ---------- init ----------
function init(){
  currentUser = { name: getRandomName(), color: getRandomColor() };
  myNameEl.textContent = currentUser.name;
  myAvatarEl.textContent = shortIdFromName(currentUser.name);
  myAvatarEl.style.background = currentUser.color;

  if (CLIENT_ID === "YOUR_SCALEDONE_CHANNEL_ID") {
    alert('Replace CLIENT_ID in HTML with your Scaledrone Channel ID before using voice.');
  }

  // connect to Scaledrone
  drone = new ScaleDrone(CLIENT_ID, { data: currentUser });

  drone.on('open', err => {
    if (err) {
      console.error('Scaledrone open error', err);
      myStatusEl.textContent = 'Error connecting';
      return;
    }
    myStatusEl.textContent = 'Online';
    console.log('Scaledrone connected:', drone.clientId);

    // setup presence room with robust local tracking
    setupPresenceRoom();
  });

  drone.on('close', () => { myStatusEl.textContent = 'Disconnected'; console.log('Scaledrone closed'); });
  drone.on('error', (err) => { myStatusEl.textContent = 'Error'; console.error('Scaledrone error', err); });
}

// ---------- PRESENCE (robust) ----------
function setupPresenceRoom() {
  try {
    presenceRoom = drone.subscribe(PRESENCE_ROOM);
  } catch (e) {
    console.error('presence subscribe failed', e);
    return;
  }

  presenceRoom.on('open', () => {
    console.log('Presence room opened');
  });

  // initial snapshot
  presenceRoom.on('members', (members) => {
    presenceMembers.clear();
    members.forEach(m => {
      presenceMembers.set(m.id, m.clientData || {});
    });
    renderMembersList();
  });

  // track joins
  presenceRoom.on('member_join', (m) => {
    presenceMembers.set(m.id, m.clientData || {});
    renderMembersList();
  });

  // track leaves
  presenceRoom.on('member_leave', (m) => {
    presenceMembers.delete(m.id);
    renderMembersList();
  });
}

function renderMembersList() {
  membersListEl.innerHTML = '';
  membersCountHeader.textContent = presenceMembers.size;
  presentCountEl.textContent = presenceMembers.size;

  presenceMembers.forEach((data, id) => {
    const name = (data && data.name) || 'Unknown';
    const color = (data && data.color) || '#5865F2';
    const el = document.createElement('div');
    el.className = 'member-item';
    el.innerHTML = `
      <div class="member-avatar" style="background:${color}">${(name||'U').charAt(0).toUpperCase()}</div>
      <div style="flex:1">
        <div class="member-name">${name}</div>
        <div class="member-presence">Online</div>
      </div>
    `;
    membersListEl.appendChild(el);
  });

  // update voice participants UI if in channel
  refreshVoiceParticipantsUI();
}

// ---------- voice helpers ----------
function voiceRoomName(room) { return VOICE_ROOM_PREFIX + room; }

async function ensureLocalStream() {
  if (localStream) return localStream;
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    // apply muted state
    localStream.getAudioTracks().forEach(t => t.enabled = !muted);
    return localStream;
  } catch (e) {
    console.error('Mic access error', e);
    throw e;
  }
}

function cleanupPeer(peerId) {
  try {
    if (pcs[peerId]) {
      pcs[peerId].close();
      delete pcs[peerId];
    }
    const a = document.getElementById('audio-'+peerId);
    if (a) a.remove();
  } catch (e) { console.warn('cleanupPeer', e); }
}

function closeAllPeers() {
  Object.keys(pcs).forEach(p => cleanupPeer(p));
  pcs = {};
}

function createPeerConnection(peerId, roomName, initiator=false) {
  if (pcs[peerId]) return pcs[peerId];
  const pc = new RTCPeerConnection({
    iceServers: [
      { urls: 'stun:stun.l.google.com:19302' },
      // Add TURN server here if you have one for better reliability
    ]
  });
  pcs[peerId] = pc;

  // add local audio if present
  if (localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  // incoming track: create/attach audio
  pc.ontrack = (evt) => {
    const stream = evt.streams[0];
    if (!stream) return;
    let audio = document.getElementById('audio-'+peerId);
    if (!audio) {
      audio = document.createElement('audio');
      audio.id = 'audio-'+peerId;
      audio.autoplay = true;
      audioContainer.appendChild(audio);
    }
    audio.srcObject = stream;
  };

  // ICE -> publish to voice room
  pc.onicecandidate = (ev) => {
    if (!ev.candidate) return;
    try {
      drone.publish({ room: voiceRoomName(roomName), message: { type:'candidate', candidate: ev.candidate, from: drone.clientId } });
    } catch (e) { console.warn('publish ice failed', e); }
  };

  if (initiator) {
    pc.createOffer().then(offer => {
      return pc.setLocalDescription(offer).then(() => {
        try {
          drone.publish({ room: voiceRoomName(roomName), message: { type:'offer', sdp: pc.localDescription, from: drone.clientId } });
        } catch (e) { console.warn('publish offer failed', e); }
      });
    }).catch(e => console.warn('createOffer failed', e));
  }

  return pc;
}

async function handleSignal(message, member, roomName) {
  if (!message) return;
  const fromId = message.from || (member && member.id);
  if (!fromId || fromId === drone.clientId) return;

  // ensure pc exists
  if (!pcs[fromId]) createPeerConnection(fromId, roomName, false);
  const pc = pcs[fromId];
  if (!pc) return;

  if (message.type === 'offer' && message.sdp) {
    try {
      await ensureLocalStream();
      // ensure tracks are attached
      if (localStream) localStream.getTracks().forEach(t => {
        try { pc.addTrack(t, localStream); } catch(e) {}
      });
      await pc.setRemoteDescription(new RTCSessionDescription(message.sdp));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      drone.publish({ room: voiceRoomName(roomName), message: { type:'answer', sdp: pc.localDescription, from: drone.clientId } });
    } catch (e) { console.error('handle offer failed', e); }
  } else if (message.type === 'answer' && message.sdp) {
    try {
      await pc.setRemoteDescription(new RTCSessionDescription(message.sdp));
    } catch (e) { console.error('setRemoteDescription(answer) failed', e); }
  } else if (message.type === 'candidate' && message.candidate) {
    try {
      await pc.addIceCandidate(new RTCIceCandidate(message.candidate));
    } catch (e) { console.warn('addIceCandidate failed', e); }
  }
}

// join voice channel
async function joinVoiceChannel(roomName) {
  if (!drone) { alert('Signaling not ready'); return; }

  if (joinedChannel === roomName) {
    leaveVoiceChannel();
    return;
  }

  // leave existing
  leaveVoiceChannel();

  // get mic
  try {
    await ensureLocalStream();
  } catch (e) {
    alert('Microphone permission is required to join voice.');
    return;
  }

  joinedChannel = roomName;
  headerTitle.textContent = roomName;
  vcStatus.textContent = 'Connecting...';
  vpTitleEl.textContent = roomName;

  // subscribe to voice room
  try {
    voiceRoom = drone.subscribe(voiceRoomName(roomName));
  } catch (e) {
    console.error('subscribe voice room failed', e);
    voiceRoom = null;
  }

  if (!voiceRoom) {
    vcStatus.textContent = 'Error';
    return;
  }

  // keep a Map of current voice room members
  voiceRoomMembers.set(roomName, new Map());

  voiceRoom.on('open', err => { if (err) console.error('voice room open', err); });

  voiceRoom.on('members', (members) => {
    const mmap = new Map();
    members.forEach(m => {
      mmap.set(m.id, m.clientData || {});
      // create peer for each existing member (initiate)
      if (m.id !== drone.clientId && Object.keys(pcs).length < (MAX_PEERS-1)) {
        createPeerConnection(m.id, roomName, true);
      }
    });
    voiceRoomMembers.set(roomName, mmap);
    refreshVoiceParticipantsUI();
  });

  voiceRoom.on('member_join', (m) => {
    if (m.id === drone.clientId) return;
    // add to map
    const mr = voiceRoomMembers.get(roomName) || new Map();
    mr.set(m.id, m.clientData || {});
    voiceRoomMembers.set(roomName, mr);
    // create connection to the new member (offer)
    if (!pcs[m.id]) createPeerConnection(m.id, roomName, true);
    refreshVoiceParticipantsUI();
  });

  voiceRoom.on('member_leave', (m) => {
    // remove from map and cleanup peer
    const mr = voiceRoomMembers.get(roomName);
    if (mr) { mr.delete(m.id); voiceRoomMembers.set(roomName, mr); }
    cleanupPeer(m.id);
    refreshVoiceParticipantsUI();
  });

  voiceRoom.on('data', (message, member) => {
    handleSignal(message, member, roomName);
  });

  vcStatus.textContent = 'Connected';
  // highlight active
  document.querySelectorAll('.voice-channel').forEach(el=>el.classList.remove('active'));
  const el = document.querySelector('.voice-channel[vc="'+roomName+'"]');
  if (el) el.classList.add('active');

  refreshVoiceParticipantsUI();
}

// leave voice
function leaveVoiceChannel() {
  if (voiceRoom) {
    try { drone.unsubscribe(voiceRoomName(joinedChannel)); } catch(e) {}
    voiceRoom = null;
  }
  // stop local stream
  if (localStream) {
    localStream.getTracks().forEach(t => { try { t.stop(); } catch(e){} });
    localStream = null;
  }
  // close all peer connections and remove audio elements
  closeAllPeers();
  joinedChannel = null;
  headerTitle.textContent = 'No voice channel selected';
  vcStatus.textContent = 'Not connected';
  vpTitleEl.textContent = 'â€”';
  // clear highlight
  document.querySelectorAll('.voice-channel').forEach(el=>el.classList.remove('active'));
  // clear participants
  refreshVoiceParticipantsUI();
}

// toggle join called by UI
function toggleJoinVoice(name) {
  joinVoiceChannel(name).catch(e => {
    console.error('joinVoiceChannel failed', e);
    alert('Failed to join voice: '+(e && e.message?e.message:'Unknown'));
  });
}
function leaveVoiceIfJoined(){ if (joinedChannel) leaveVoiceChannel(); }
function promptJoinLast(){ if (!joinedChannel) joinVoiceChannel(VOICE_CHANNELS[0]); else leaveVoiceChannel(); }

// mute/unmute
function toggleMute() {
  muted = !muted;
  if (localStream) localStream.getAudioTracks().forEach(t => t.enabled = !muted);
  muteBtn.textContent = muted ? 'Unmute' : 'Mute';
  muteBtn.style.background = muted ? '#444' : '';
}

// ---------- Voice participants UI ----------
function refreshVoiceParticipantsUI() {
  voiceParticipantsEl.innerHTML = '';
  if (!joinedChannel) {
    voiceParticipantsEl.innerHTML = '<div style="color:var(--muted)">Not in a voice channel</div>';
    return;
  }

  // prefer the exact voiceRoomMembers map if present
  const mr = voiceRoomMembers.get(joinedChannel);
  if (mr && mr.size > 0) {
    renderVoiceParticipants(Array.from(mr.values()).map((cd, idx)=>({ clientData: cd, id: Array.from(mr.keys())[idx] })));
    return;
  }

  // fallback: show presence members (best-effort)
  const fallback = [];
  presenceMembers.forEach((data, id) => {
    fallback.push({ id, clientData: data });
  });
  if (fallback.length > 0) {
    renderVoiceParticipants(fallback.slice(0, MAX_PEERS));
    return;
  }

  voiceParticipantsEl.innerHTML = '<div style="color:var(--muted)">No participants</div>';
}

function renderVoiceParticipants(list) {
  voiceParticipantsEl.innerHTML = '';
  if (!list || list.length === 0) {
    voiceParticipantsEl.innerHTML = '<div style="color:var(--muted)">No participants</div>';
    return;
  }
  list.forEach(item => {
    const data = item.clientData || {};
    const name = data.name || 'Unknown';
    const color = data.color || '#5865F2';
    const wrap = document.createElement('div');
    wrap.className = 'member-item';
    wrap.innerHTML = `
      <div class="member-avatar" style="background:${color}">${(name||'U').charAt(0).toUpperCase()}</div>
      <div style="flex:1">
        <div class="member-name">${name}</div>
        <div class="member-presence">In ${joinedChannel}</div>
      </div>
    `;
    voiceParticipantsEl.appendChild(wrap);
  });
}

// ---------- init on load ----------
window.addEventListener('load', () => {
  try { init(); } catch (e) { console.error('init error', e); }
  // attach mute default text
  muteBtn.textContent = 'Mute';
});
</script>
</body>
</html>
